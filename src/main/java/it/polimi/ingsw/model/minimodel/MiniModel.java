package it.polimi.ingsw.model.minimodel;

import it.polimi.ingsw.model.cards.ProductionCard;
import it.polimi.ingsw.model.dashboard.Deposit;
import it.polimi.ingsw.model.resources.Resource;
import it.polimi.ingsw.utils.ConstantValues;
import it.polimi.ingsw.utils.DebugMessages;
import it.polimi.ingsw.view.observer.Observable;
import it.polimi.ingsw.view.scenes.BasicSceneUpdater;

import java.util.List;
import java.util.Stack;

/**
 * Rappresent game state inside view
 */
public class MiniModel extends Observable<BasicSceneUpdater>
{

    private int lorenzo;
    private int persanalIndex = 0;
    private boolean isLoaded = false;
    private MiniPlayer[] players;
    private ProductionCard [][] decks;
    private String currentlyplaying;
    public MiniModel()
    {
        players = new MiniPlayer[ConstantValues.numberOfPlayer];
    }

    public String getCurrentlyplaying() {
        return currentlyplaying;
    }

    public void setCurrentlyplaying(String currentlyplaying) {
        this.currentlyplaying = currentlyplaying;
    }

    public MiniPlayer getPersonalPlayer()
    {
        return this.players[persanalIndex];
    }

    /**
     * Called when a new card sis buyed from shop
     * @param newCard       card to put inside shop
     * @param x             col shop
     * @param y             row shop
     * @param dashboardPos   dash position to update
     * @param index         player who buyed
     */
    public void updateCard(ProductionCard newCard,int x,int y,int dashboardPos,int index)
    {
        players[index].setNewCard(dashboardPos,decks[x][y]);
        decks[x][y] = newCard;
        System.out.println("Dash updated");

        this.notifyObserver(scene -> scene.updateDeckCard(newCard,x,y));
    }

    /**
     * Load decks from real model and convert to minimodel format
     * @param decks decks from game model
     */
    public void setDeck(Stack<ProductionCard>[][] decks)
    {
        //this.decks = new ProductionCard[ConstantValues.colDeck][ConstantValues.rowDeck];

        this.decks = new ProductionCard[3][4];
        int i=0;
        for(Stack<ProductionCard>row[] :decks)
        {
            int j=0;
            for(Stack<ProductionCard> cards:row)
            {
                if(!cards.isEmpty())
                    this.decks[i][j] = cards.peek();
                j++;
            }
            i++;
        }
        DebugMessages.printError("set finisched loading");
        isLoaded = true;
    }


    /**
     *
     * @return true if model is loadel 100% (to avoid to do model access before its loaded)
     */
    public boolean isLoaded()
    {
        return isLoaded;
    }

    /**
     * This minimodel has only ONE observer at time so this function change it if needed
     * @param currScene  current scene that observe
     */
    public void setModelObserver(BasicSceneUpdater currScene)
    {
        for(MiniPlayer p:players)
        {
            if(p!=null)
                p.setObserver(currScene);
        }

        this.setObserver(currScene);
    }

    /**
     * used by server to generate Minimodel, Set a miniplayer
     * @param players array of miniplayer generated by server
     */
    public void setPlayers(MiniPlayer[] players) { this.players = players; }

    /**
     *
     * @return list of miniplayer inside this match
     */
    public MiniPlayer[] getPlayers() { return players; }

    /**
     *
     * @param deposits new deposit recived from server
     * @param index    player which recived update
     */
    public void updateStorage(Deposit[] deposits,int index)
    {
        players[index].setStorage(deposits);
    }

    /**
     *
     * @return storage of this client (use personal index to retrive it)
     */
    public Deposit[] getStorage()
    {
        return players[persanalIndex].getStorage();
    }

    /**
     *
     * @return chest of this client (use personal index to retrive it)
     */
    public List<Resource> getChest()
    {
        return players[persanalIndex].getChest();
    }

    /**
     *
     * @return the entire shop in card matrix format
     */
    public ProductionCard[][] getDecks()
    {
        return this.decks;
    }

    /**
     *
     * @return personal index of this client
     */
    public int getPersanalIndex() { return persanalIndex; }

    /**
     * set the index of this client inside the GAME "players" list
     * @param index player index of this client
     */
    public void setPersanalIndex(int index)
    {
        this.persanalIndex = index;
    }

    /**
     * update minimodel chest
     * @param chest new chest
     * @param index player who recived update
     */
    public void updateChest(List<Resource> chest,int index)
    {
        this.players[index].updateChest(chest);
    }

    /**
     * Set lorenzo new position
     * @param pos lorenzo new pos
     */
    public void lorenzoPositionUpdate(int pos) {
        lorenzo = pos;
    }

    /**
     * update minimodel decks by discarding card drawed by lorenzo
     * @param x        col deck
     * @param y        row deck
     * @param newCard  new card to put inside view
     */
    public void lorenzoCardDiscard(int x,int y,ProductionCard newCard)
    {
        this.decks[x][y] = newCard;
        this.notifyObserver(scene -> scene.updateDeckCard(newCard,x,y));
    }

    /**
     *
     * @return lorenzo position
     */
    public int getLorenzo()
    {
        //Observer per draware lorenzo
        return lorenzo;
    }
}
